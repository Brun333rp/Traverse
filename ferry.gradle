buildscript {
	repositories {
		maven {
			url "https://plugins.gradle.org/m2/"
		}
	}

	dependencies {
		classpath "net.dumbcode.gradlehook:GradleHook:1.3.1"
		classpath "gradle.plugin.com.matthewprenger:CurseGradle:1.4.0"
	}
}

apply plugin: net.dumbcode.gradlehook.GradleWebhookPlugin
apply plugin: com.matthewprenger.cursegradle.CurseGradlePlugin

apply from: 'terraformers-mod.gradle'

def curseReleaseType = "release"
def releaseChangelog = "No Changelog Available"
def stabilitySuffix = ""

task buildAndAttemptRelease {

}

buildAndAttemptRelease {
	def changes = StringBuilder.newInstance()
	def proc = "git log --max-count=$project.changelog_max_commit_search --pretty=format:\"%s\"".execute()
	def latestCommit = true
	def release = false
	def cancel = false
	def releaseType = project.default_release_type

	proc.in.eachLine { line -> // Loops over the lines the git log command returns
		def processedLine = line.toString()
		if (cancel) {
			return
		}
		if (latestCommit) {
			if (processedLine.contains("#release")) {
				if (processedLine.contains("#release stable")) {
					releaseType = "stable"
				} else if (processedLine.contains("#release beta")) {
					releaseType = "beta"
					curseReleaseType = "beta"
					stabilitySuffix = " (Beta)"
				} else if (processedLine.contains("#release alpha")) {
					releaseType = "alpha"
					curseReleaseType = "alpha"
					stabilitySuffix = " (Alpha)"
				}
				release = true
			}
		}
		if (!latestCommit && processedLine.contains("#release")) {
			// Cancel if it finds another release (that isn't the first one)
			cancel = true
			return
		}
		if (release) {
			if (project.changelog_type == "commit_change_tags") {
				def splitLine = processedLine.split(/\#change /)
				println "Adding changelog lines for commit $processedLine"
				def firstSplit = true
				splitLine.each { string ->
					println " Commit: $processedLine - has string: $string"
					if (firstSplit) {
						firstSplit = false
						return
					}
					if (string.startsWith("\"")) {
						try {
							def matches = string =~ /"(.*?)"/
							def message = matches[0][1]
							println "   Read as message: $message"
							if (!message.isAllWhitespace()) {
								if (changes.length() == 0) {
									changes << "- $message"
								} else {
									changes << "\n- $message"
								}
							}
						} catch (Exception e) {
							println "Exception adding changelog message: $string"
						}
					}
				}
			} else if (project.changelog_type == "literal_commits") {
				if (project.changelog_hide_unimportant_commits.toBoolean() && processedLine.startsWith("Merge") && processedLine.contains("branch")) {
					return
				}
				if (changes.length() == 0) {
					changes << "- $processedLine"
				} else {
					changes << "\n- $processedLine"
				}
			}
		}
		if (latestCommit) {
			latestCommit = false
		}
	}
	proc.err.eachLine { line -> println line }
	proc.waitFor()
	if (release) {
		println "This build IS scheduled to be released"
		releaseChangelog = changes.toString()
		println releaseChangelog
		dependsOn tasks.getByName("curseforge")
	} else {
		println "This build is NOT scheduled to be released"
	}
	dependsOn build
}

curseforge {
	apiKey = System.getenv().CURSEFORGE_TOKEN ? System.getenv().CURSEFORGE_TOKEN : "###"
	project {
		id = project.curseforge_id
		releaseType = curseReleaseType
		project.curseforge_game_versions.split(", ").each {
			String gameVersion -> addGameVersion gameVersion
		}
		changelog = releaseChangelog
		mainArtifact(file("${project.buildDir}/libs/${archivesBaseName}-${version}.jar"))
		mainArtifact.displayName = "$project.project_name v$version for $project.minecraft_version"
		if (!project.curseforge_required_dependencies.isEmpty() || !project.curseforge_optional_dependencies.isEmpty()) {
			relations {
				if (!project.curseforge_required_dependencies.isEmpty()) {
					project.curseforge_required_dependencies.split(", ").each {
						String dep -> requiredDependency dep
					}
				}
				if (!project.curseforge_optional_dependencies.isEmpty()) {
					project.curseforge_optional_dependencies.split(", ").each {
						String dep -> optionalDependency dep
					}
				}
			}
		}
		afterEvaluate {
			uploadTask.dependsOn(remapJar)
		}
	}
	options {
		forgeGradleIntegration = false
	}
}

tasks.getByName("curseforge").doLast {
	if (System.getenv().DISCORD_ANNOUNCEMENT_WEBHOOK) {
		println "Preparing webhook"
		def fileId = (tasks.getByName("curseforge$curseforge_id").property("mainArtifact"))['fileID']
		def curseforge_download = "https://www.curseforge.com/minecraft/mc-mods/$project.curseforge_slug/files/$fileId"
		def github_download = "https://www.youtube.com/watch?v=dQw4w9WgXcQ"
		def release_url = curseforge_download
		def discordChangelog = createDiscordChangelog(release_url)

		def result = DiscordBuilder.createForm {
			if (project.use_project_username.toBoolean()) {
				avatar_url = project.project_logo
				username = project.project_name
			}
			embed {
				color = Integer.decode(project.project_color)
				author {
					name = project.project_name + stabilitySuffix
					url = project.project_url
				}
				thumbnail { url = project.project_logo }
				title = "$project.project_name v$version for $project.minecraft_version Released"
				url = release_url
				field {
					name = "Changes:"
					value = discordChangelog
				}
				field {
					name = "Downloads:"
					value = "[$curseforge_emote CurseForge]($curseforge_download)"
				}
				footer {
					text = "A $project.loader_name Mod"
					icon_url = project.loader_icon
				}
			}
		}.send(System.getenv().DISCORD_ANNOUNCEMENT_WEBHOOK)

		println "Discord Webhook Response: " + result.responseCode
	}
}

// Truncates changelogs for the Discord Webhook
ext.createDiscordChangelog = { fullChangelogUrl ->
	def webhookChangelog = StringBuilder.newInstance()
	def changelogLines = releaseChangelog.split("\n")
	def maxLines = Integer.decode(project.discord_webhook_changelog_line_limit)
	if (changelogLines.length <= maxLines) {
		return releaseChangelog
	} else {
		def lines = 0
		changelogLines.find { line ->
			if (webhookChangelog.length() == 0) {
				webhookChangelog << line
			} else {
				webhookChangelog << "\n$line"
			}
			lines++
			if (lines >= maxLines) {
				webhookChangelog << "\n(+ " + (changelogLines.length - lines) + " more) See [Full Changelog]($fullChangelogUrl)"
				return true;
			}
		}
	}
	return webhookChangelog.toString()
}
